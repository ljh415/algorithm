## Sort

#### 정렬하는 알고리즘들을 간단하게 코드로 짜서 추후에 Github에 올릴 예정



- 정렬이란

  2개 이상의 자료를 특정 기준으로 재배열하는 것

  오름차순 / 내림차순

  +. 키 → 자료를 정렬하는 기준이 되는 특정 값

- 대표적인 정렬

  - 버블 정렬

    - 인접한 두 개의 원소를 비교하며 자리를 교환하는 방식

      1. 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동
      2. 한 단계가 끝나면 가장 큰 원소 또는 가장 작은 원소가 마지막 자리로 정렬됨

    - 시간복잡도 : $O(n^2)$

    - 의사코드

      ```python
      def BubbleSort(a):
      	for i in range(len(a)-1, 0, -1):  # 범위의 끝 위치
      		for j in range(0, i):
      			if a[j] > a[j+1]:
      				a[j], a[j+1] = a[j+1], a[j]
      ```

  - 카운팅 정렬 ( `from collections import Counter` 와 비슷)

    - 항목들의 순서를 결정하기 위해 집합의 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘

    - 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능

    - 충분한 공간을 할당하려면 가장 큰 정수를 알아야 한다

    - 시간 복잡도 : $O(n+k)$

      $n$은 리스트의 개수, $k$는 정수의 최대값

    1. Data에서 각 항목들의 발생 회수를 세고, 정수 항목들로 직접 인덱스 되는 카운트 리스트 COUNTS에 저장

       → 항목들중 최대값이 인덱스에 맞춰서 COUNTS 배열 생성

    2. 정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 COUNTS의 원소를 조정

       → index가 늘어나면서 값들을 누적해서 표현

    - 의사코드

      ```python
      def CountingSort(A, B, k):
      # A[1 .. n] -- 입력 리스트 사용된 숫자(1~k)
      # B[1 .. n] -- 정렬된 리스트
      # C[1 .. k] -- 카운트 리스트
      
      	C = [0] * k
      
      	for i in range(0, len(B)):
      		C[A[i]] += 1
      
      	for i in range(1, len(C)):
      		C[i] += C[i-1]
      
      	for i in range(len(B)-1, -1, -1):
      		B[C[A[i]]-1] = A[i]
      		C[A[i]] -= 1
      ```

    ```python
    a = [0, 4, 1, 3, 1, 2, 4, 1]
    b = [0] * len(a)
    CountingSort(a, b, 5)
    print(b)
    ```

  - 선택 정렬

    - 앞에서부터 최소값을 선택해서 채워나간다.

    ```python
    def selection(numbers):
    
        for i in range(len(numbers)) :
            min_num = min(numbers[i:])
            numbers[numbers.index(min_num)], numbers[i] = numbers[i], numbers[numbers.index(min_num)]
    
        return numbers
    ```

  - 퀵 정렬

    - **분할 정복** 알고리즘
    - 기준 값 (**피벗, Pivot**)을 사용
      - 피벗 값을 기준으로 크면 오른쪽, 작으면 왼쪽으로 정렬
      - 이전 피벗을 기준으로 보다 작은 <u>왼쪽</u>, 보다 큰 <u>오른쪽</u>이 나뉘어지게 된다.
      - 각 부분에서 또 다른 피벗 값을 설정후 위 과정 반복
    - 평균 시간 복잡도 : O(N * logN) / 최악 시간 복잡도 : O(N^2)

  - 삽입 정렬

    - 데이터가 이미 '거의 정렬된' 상태라면 가장 효율적인 알고리즘
    - 각 숫자를 적절한 위치에 삽입하는 방법, **필요할 때만** 위치를 바꾼다.
    - 앞에서 부터 시작, 현재 숫자와 앞에 있는 숫자들을 비교하면서 알맞은 위치에 삽입
    - 시간 복잡도 : $O(n^2)$

  - 병합 정렬

    - **분할 정복** 알고리즘
    
    - 하나의 큰 문제를 두 개의 작은 문제로 반할한 뒤에 각자 계산하고 나중에 합치는 방법
    
    - 시간 복잡도 O(N * logN)
    
      
